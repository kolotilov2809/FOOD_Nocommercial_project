
window.addEventListener('DOMContentLoaded', function() {//назначение глобального обработчика событий

    // Tabs
    
	let tabs = document.querySelectorAll('.tabheader__item'),//получаем табы, на которые будем кликать
		tabsContent = document.querySelectorAll('.tabcontent'),//весь контент, который находится в верстке
		tabsParent = document.querySelector('.tabheader__items');//родитель, который будет содержать все табы
    //скроем все ненужные нам табы
	function hideTabContent() {
        
        tabsContent.forEach(item => {//так как у нас псевдомассив, мы его перебираем forEach. item - внутри будет каждый отдельный контент
            //item.style.display = 'none';
            item.classList.add('hide');
            item.classList.remove('show', 'fade');
        });
        //когда мы скрываем все табы из видимости, мы так же будем убирать все класс активности у всх табов, которые там находятся
        tabs.forEach(item => {
            item.classList.remove('tabheader__item_active');// у каждого элемента табов, будем убирать класс активности. перед tabheader__item_active не ставим точку, потому что classList и так говорит, что мы будем работать с классами
        });
	}
    //функция, которая нам будет показывать табы
	function showTabContent(i = 0) {//параметр по умолчанию
        //tabsContent[i].style.display = 'block';//обращаемся к контенту. нужно строго понимать к какому контенту мы обращаемся.Этот номер, который нам нужно показать, мы будем передавать, как аргумент i.
        tabsContent[i].classList.add('show', 'fade');
        tabsContent[i].classList.remove('hide');
        tabs[i].classList.add('tabheader__item_active');//так как есть работа с классом активности, поэтому добавляем класс
    }
    
    hideTabContent();
    showTabContent();//вызываем функцию без аргумента. по умолчанию выставится параметр i = 0, который описан выше
    
    //делегирование событий, назначаем обработчик клика
	tabsParent.addEventListener('click', function(event) {//к родителю всех табов, назначаем обработчик события click,далее создаем callback функцию (передаем объект событие event)
		const target = event.target;//когда часто используют event.target мы можем его переопределить в определенную переменную. это делается для того, что если нам придется много использовать конструкцию event.target, то удобнее использовать переменную
		if(target && target.classList.contains('tabheader__item')) {//проверяем сначала просто на target, потом target.classList с помощью contains определять, что точно кликнули в таб
            //когда мы кликнули в определенный пункт, мы должны определить его номер в списке всех наших табов и по его номеру вызвать showTabContent(i), чтобы определенный таб показатьСделать это можно обычным перебором forEach. Мы перебираем все табы, которые лежат в переменной tabs. и сравниваем, что если элемент, который находится в этом псевдомассиве совпадает с тем элементом, в который кликнул пользователь, тогда мы берем его номер и показываем на странице
            tabs.forEach((item, i) => {//берем tabs - псевдо массив. перебираем forEach , передаем callback функцию с двумя аргументами item - каждый таб, который будем перебирать, i  - номер элемента по порядку
                if (target == item) {//если target - тот элемент, который мы только что кликнули будет совпадать с элементом , который мы сейчас перебираем item в цикле forEach, если это один и тот же элемент , то мы будем вызывать две наши функции 
                    hideTabContent();//скрываем другие табы
                    showTabContent(i);//i - номер того элемента, который совпал. показываем таб, который кликнул пользователь

window.addEventListener('DOMContentLoaded', function() {

    // Timer

    //переменная, которая определяет дедлайн
    const deadline = '2022-05-11';//поместим дату в виде строки

    //функция которая определяет разницу между дедлайном и текущим временем
    function getTimeRemaining(endtime) {
        const t = Date.parse(endtime) - Date.parse(new Date()), //в переменную t  положим результат. Date.parse(endtime) - колво миллисекунд, которое будет в нашем конечном времени. Date.parse(new Date()) - текущее время//когда функция запустится. мы получим разницу между
            //когда получим разницу в миллисекундах. нам надо превратить в количество дней, минут 
            days = Math.floor( (t/(1000*60*60*24)) ),//нам надо посчитать количество дней отображаемых в таймере
            seconds = Math.floor( (t/1000) % 60 ),//получаем секунды
            minutes = Math.floor( (t/1000/60) % 60 ),//получаем минуты
            hours = Math.floor( (t/(1000*60*60) % 24) );//получаем часы
//для возвращения переменных days hours minutes seconds наружу
        return {//вернем их объектом.эти данные будут помещены на страницу
            'total': t,
            'days': days,
            'hours': hours,
            'minutes': minutes,
            'seconds': seconds
        };
    }


    //подставление 0. функция помощник. Когда у нас дней,часов, минут и секунд меньше 10, то что бы отображение было двумя цифрами (01,09). Мы допишем функцию
    function getZero(num){//проверяем число
        if (num >= 0 && num < 10) { //если это число больше или равно 0 и число меньше 10
            return '0' + num;//то из нашей функции будем возвращать уже модифицированное значение, а именно берем строку и подставляем в значение 0
        } else {
            return num;//иначе вернуть просто число
        }
    }

    //функция, которая устанавливает наш таймер на страницу
    function setClock(selector, endtime) {//нам необходим блок, куда вставим таймер class="timer", обозначаем selector. а так же сам дедлайн, который будем ему передавать endtime

        //далее создаем переменные, в которые будем помещать элементы со страницы
        const timer = document.querySelector(selector),
            days = timer.querySelector("#days"),//забиваем уникальные id со страницы
            hours = timer.querySelector('#hours'),
            minutes = timer.querySelector('#minutes'),
            seconds = timer.querySelector('#seconds'),
            timeInterval = setInterval(updateClock, 1000);//обновление времени. запускаем функцию updateClock через каждую 1 секунду

        updateClock();//Чтобы не было мигания на странице (отображаются в таймере цифры, которые стоят в верстке). Это происходит потому что, наша функция updateClock запускается с интервалом в 1 секунду. поэтому мы вручную запускаем updateClock. это такая функция инициализации, которая один раз запустится, установит текущую дату и потом она исчезнет и будет работать setInterval

        function updateClock() {//обновление таймера каждую секунду
            const t = getTimeRemaining(endtime);//расчет времени , который остался на эту секунду

            //поместить расчетные единицы на странице. Применяем функцию помощник getZero, чтобы подставить 0 для однозначных чисел

    function getZero(num){
        if (num >= 0 && num < 10) { 
            return '0' + num;
        } else {
            return num;
        }
    }

    function setClock(selector, endtime) {

        const timer = document.querySelector(selector),
            days = timer.querySelector("#days"),
            hours = timer.querySelector('#hours'),
            minutes = timer.querySelector('#minutes'),
            seconds = timer.querySelector('#seconds'),
            timeInterval = setInterval(updateClock, 1000);

        updateClock();

        function updateClock() {
            const t = getTimeRemaining(endtime);


            days.innerHTML = getZero(t.days);
            hours.innerHTML = getZero(t.hours);
            minutes.innerHTML = getZero(t.minutes);
            seconds.innerHTML = getZero(t.seconds);

            if (t.total <= 0) {//чтобы остановить таймер. Если время уже вышло (в отрицательную сторону или равно 0)
                clearInterval(timeInterval);//то таймер больше не обновлять

            if (t.total <= 0) {
                clearInterval(timeInterval);

            }
        }
    }

    setClock('.timer', deadline);

    // Modal


    const modalTrigger = document.querySelectorAll('[data-modal]'),//вызываем кнопки через data атрибут, которые будут вызывать модальное окно
        modal = document.querySelector('.modal');//отвечает за модальное окно

        //убираем эту переменную, потому что надо реализовать другой функционал. Объяснение начинается с //функция красивого оповещения польз-ля 
    //const modalCloseBtn = document.querySelector('[data-close]');//кнопка отвечает за закрытие модального окна

    //принцип dry. Код не должен повторяться. для повторяющегося кода лучше создать функцию.

    modalTrigger.forEach(btn => {//используем метод forEach, то что внутри будет какая то кнопка
        btn.addEventListener('click', openModal);//когда кликаем по кнопке для вызова модал окна
    });

    function closeModal() {//функция для закрытия модал окна
        modal.classList.add('hide');//к модальному окну добавляем класс  hide
        modal.classList.remove('show');//удаляем у модал кона класс show
        //через tooggle
        //modal.classList.toggle('show');
        document.body.style.overflow = '';//чтобы вернуть управление к элементам на странице после закрытия модал окна, оставляем кавыхи пустыми и браузер по умолчанию восстановит
    }

    function openModal() {//функция появления модал окна
        modal.classList.add('show');//к модальному окну добавляем класс show
        modal.classList.remove('hide');//удаляем у модал кона класс hide
        //через tooggle
        // modal.classList.toggle('show');
        document.body.style.overflow = 'hidden';//чтобы страницу не было возможности прокручивать или что то кликать, то мы скрываем прячем манипуляции со всем что находится в body
        clearInterval(modalTimerId);//если пользователь сам открыл модал окно, то мы очистим интервал открытия модал окна(чтобы само не включались)
    }

        //когда кликаем по кнопке для закрытия модал окна
    //закомментили для работы крестика при любых условиях
    //modalCloseBtn.addEventListener('click', closeModal);

    modal.addEventListener('click', (e) => {//Чтобы закрыть модал окно по клику в любую область на странице. на наше модальное окно навешиваем обработчик клика
        //(e) =>  передаем callback функцию с объектом события (е). 
        if (e.target === modal || e.target.getAttribute('data-close') == "") {//если event.target(куда кликнул пользователь) будет строго совпадать с modal
            //|| e.target.getAttribute('data-close') == '' или e.target будет крестиком для закрытия модал окна мы можем получить атрибут data-close, если он действительно присутствует на этом элементе, то мы будем закрывать модал окно. Поэтому используем команду getAttribute и помещаем data-close  и что он будет равен пустой строке, потому что мы туда ничего не помещаем. И теперь если кликаем куда то на подложку или крестик, у нас закрывается модал окно
            closeModal();//функция закрытия модал окна(dry)
        }
    });

    //для закрытия модал окна с помощью escape
    //keydown - событие по нажатию по кнопке с клавиатуры
    //событие вешается на document, а не на какое то конкретный элемент
    document.addEventListener('keydown', (e) => {        //(e) =>  передаем callback функцию с объектом события (е)

        //code - событие для отслеживания кода клавиш. для кнопки Escape код Escape
        //если нажали клавишу равную коду Escape, то закрыть модал окно
        //чтобы функция closeModal не вызывалась просто по нажатию на Escape добавляем && и при этом модальное окно открыто(contains  содержится ли класс show у модального окна(открыто то ли оно))
        if (e.code === "Escape" && modal.classList.contains('show')) { 
            closeModal();//функция закрытия модал окна(dry)
        }
    });

    const modalTimerId = setTimeout(openModal, 500000);//чтобы модал окно появлялось по прошествии времени
    // Изменил значение, чтобы не отвлекало

    function showModalByScroll() {//функция для открытия модал окна, если польз-ль долистал до конца страницы
         //если окно.прокрученная часть + видимая часть, которую видим на данный момент >= если эта сумма больше или равна полностью размеру всей страницы
        if (window.pageYOffset + document.documentElement.clientHeight >= document.documentElement.scrollHeight) {
            openModal();//то запустить функцию открытия модал окна
            window.removeEventListener('scroll', showModalByScroll);//далее удаляем обработчик события если он выполнился. Чтобы не было, что каждый раз листая страницу до конца вылетало модал окно
        }
    }
    window.addEventListener('scroll', showModalByScroll);//если пользователь долистал до конца страницы, модал окно должно открыться

    // Используем классы для создание карточек меню

    class MenuCard {//создадим шаблон класс, чтобы от него отпочковывать карточки
        constructor(src, alt, title, descr, price, parentSelector, ...classes) {//создаем конструктор. src = путь картинки, alt = альтернатив текст, если картинка не подгрузилась, title = заголовок карточки, descr = описание, price = цена. Зададим эти св-ва в качестве аргументов
            //...classes - возможго при создании нашей карточки, мы захотим добавить еще какие то классы. поэтому используем rest оператор с именем classes

            this.src = src;
            this.alt = alt;
            this.title = title;
            this.descr = descr;
            this.price = price;

            this.classes = classes;//это будет массив, поэтому работать с ним надо будет как с массивом
            this.parent = document.querySelector(parentSelector);//parentSelector аргумент который будем передавать для получения куда пушить этот элемент
            this.transfer = 27;//для конвертации курса валют. чтобы перевести price из $ в UAH
            this.changeToUAH();//метод changeToUAH. Когда у нас сконструируются все св-ва(идут по порядку) у нас сработает этот метод, он возьмет наше число transfer умножит на число в price, которое придет нам как аргумент и вернет this.price как видоизмененное значение 
        }

        changeToUAH() {//метод для конвертации валют из  $ в грв
            this.price = this.price * this.transfer;//в this.price кладем значение this.price * this.transfer. Наши данные друг с другом взаимодействуют и отдают результат, которое записывается в это же св-во
        }

        render() {//метод, чтобы сформировать верстку. Здесь нам нужно создать element, в него поместить определенную верстку, эту верстку дополнить данными, которые приходят как аргументы. и поместить этот элемент уже на страницу
            const element = document.createElement('div');//создаем element, обращаемся к document, у него есть метод createElement и нам требуется создать какой то div
            //когда у нас этот элемент уже существует в JS , мы к нему обращаемся и у него есть метод innerHTML, который позволит нам динамически сформировать данную структуру. Этот div будет внутри еще одного diva.

            //Если вдруг забудем прописать дефолтный класс для создания карточки, то как же использовать параметр по умолчанию для rest оператора.То тогда мы можем написать условие
            //если вдруг в наш classes ничего не передается, this.classes обращаемся к его кол-ву элементов length ===0, в таком случае мы будем ставить дефолтный класс this.element = 'menu__item'; element.classList.add(this.element);
            //мы сделали более грамотно, вдруг в будущем нам этот класс еще понадобится, поэтому этот класс menu__item мы добавим в св-ва this.element = 'menu__item'.




            if (this.classes.length === 0) {
                this.classes = "menu__item";
                element.classList.add(this.classes);
            } else {
                this.classes.forEach(className => element.classList.add(className));
            }


            //обращаемся к  this.classes используем метод forEach. Называем каждый element внутри классов этого массива className, стрел функ =>  принимает аргумент этот аргумент className. мы обращаемся к element к новосозданному div (element = document.createElement('div')) обращаемся к его  classList и добавляю каждый класс className, который будет находитья в этом массиве
            //this.classes.forEach(className => element.classList.add(className));//так как это массив, нам надо обработать его, пройтись по каждому элементу внутри, вытащить название каждого класса и подсоединить его к созданному div
            //далее мы уберем обертку div class="menu__item"
            //далее перейдем в объявление наших классов new MenuCard


            element.innerHTML = `
                <img src=${this.src} alt=${this.alt}>
                <h3 class="menu__item-subtitle">${this.title}</h3>
                <div class="menu__item-descr">${this.descr}</div>
                <div class="menu__item-divider"></div>
                <div class="menu__item-price">
                    <div class="menu__item-cost">Цена:</div>
                    <div class="menu__item-total"><span>${this.price}</span> грн/день</div>
                </div>

            `;//теперь надо этот element поместить на страницу. поэтому нам надо получить родителя, куда мы все это будем пихать. При чем каждый раз когда будет вызываться MenuCard этот parent родитель может быть разный. Поэтому мы используем аргумент parent
            this.parent.append(element);//this.наш родитель.так как это DOM элемент, то у него есть метод append, для того чтобы наш новосозданный элемент поместили во внутрь все того же элемента
        }
    }

    //Наш класс готов. Создадим новый объект и вызовем метод render. 
    //можно сделать создав переменную div  и в нее уже поместить новый объект с аргументами и потом рендерить div
    /* const div = new MenuCard();
    div.render(); */

    getResource('http://localhost:3000/menu')
        .then(data => {
            data.forEach(({img, altimg, title, descr, price}) => {
                new MenuCard(img, altimg, title, descr, price, ".menu .container").render();
            });
        });

        //функция для получения меню с сервера
       /* const getResource = async (url) => {//Делаем запрос
            const res = await fetch(url);//дожидаемся его окончания
    
            //.ok - св-во говорит мы что то получили ок либо не ок
            //status - св-во, попадаем на статус, который вернул на сервер
            //если res не ок (с моим запросом что то не так пошло)
            if (!res.ok) {
                //то выкини ошибку
                //создаем объект ошибки new Error и внутрь помещаем текст ошибки. для того чтобы ошибка вылетела используется оператор throw
                //текст ошибки: мы не смогли зафечить по данному url, статус из res.status
                throw new Error(`Could not fetch ${url}, status: ${res.status}`);
            }
            return await res.json();//трансформируем все данные в js объект
        };*/
    
        //вызываем функцию, чтобы получить карточки с меню, обращаемся по определенному url
    /*     getResource('http://localhost:3000/menu')
            .then(data => {//data - данные, которые придут к нам с сервера. В функции мы уже выполнили, что данные трансформируется из json в js объект
                //данные хранятся в виде массива. переберем массив forEach
                 //используем синтаксис деструктуризации объекта. Это когда мы из объекта вытаскиваем отдельные св-ва в кач-ве отдельной переменной
                data.forEach(({img, altimg, title, descr, price}) => {//вытаскиваем св-ва {img, altimg, title, descr, price}
                    new MenuCard(img, altimg, title, descr, price, '.menu .container').render();//вызываем конструктор для создания объекта карточки. будет вызыватсья столько раз, сколько объектов(в виде массива) на сервере. пушим все элементы в класс .menu .container
                });
            }); */
    
         /*   axios.get('http://localhost:3000/menu')
                .then(data => {//data - данные, которые придут к нам с сервера. В функции мы уже выполнили, что данные трансформируется из json в js объект
                    //данные хранятся в виде массива. переберем массив forEach
                     //используем синтаксис деструктуризации объекта. Это когда мы из объекта вытаскиваем отдельные св-ва в кач-ве отдельной переменной
                    data.data.forEach(({img, altimg, title, descr, price}) => {//вытаскиваем св-ва {img, altimg, title, descr, price}
                        new MenuCard(img, altimg, title, descr, price, '.menu .container').render();//вызываем конструктор для создания объекта карточки. будет вызыватсья столько раз, сколько объектов(в виде массива) на сервере. пушим все элементы в класс .menu .container
                    });
                });
    */
            //второй метод получения данных с сервера. Не использует классы, а формирует верстку на лету
           /*  getResource('http://localhost:3000/menu')//обращаемся к серверу
                .then(data => createCard(data));// функция createCard получает данные
    
            function createCard(data) {//data - это массив
                data.forEach(({img, altimg, title, descr, price}) => {//перебираем через forEach. Деструктуризирует объекты на отдельные св-ва
                    const element = document.createElement('div');//создает новый див
    
                    element.classList.add('menu__item');//помещает этот див  в класс
    
                    //формирует верстку и вов нутрь помещает св-ва, которые пришли с сервера
                    element.innerHTML = `
                    <img src=${img} alt=${altimg}>
                    <h3 class="menu__item-subtitle">${title}</h3>
                    <div class="menu__item-descr">${descr}</div>
                    <div class="menu__item-divider"></div>
                    <div class="menu__item-price">
                        <div class="menu__item-cost">Цена:</div>
                        <div class="menu__item-total"><span>${price}</span> грн/день</div>
                    </div>
                    `;
    
                    document.querySelector('.menu .container').append(element);// аппендит карточку на страницу
                });
            } */
    
    
        //другой способ. Ведь объект может существовать и без переменной. Делается это тогда, когда объект используется только на месте. Поэтому можно просто написать new MenuCard().render();. То есть мы здесь создаем объект, сразу же на нем вызываем метод render, он что то сделает и исчезнет, потому что на него больше не будет ссылок. Мы нигде не сохраняем этот объект. Это удобно, когда нужно только один раз использовать.
        //Нам нужно будет передать аргументы. Так как аргументов много, то их разносят на разные строчки
        //ранее наши карточки отображались за счет html верстки, то теперь они работают за счет JS. а в html мы убрали код
        /* new MenuCard(
            "img/tabs/vegy.jpg",
            "vegy",
            'Меню "Фитнес"',
            'Меню "Фитнес" - это новый подход к приготовлению блюд: больше свежих овощей и фруктов. Продукт активных и здоровых людей. Это абсолютно новый продукт с оптимальной ценой и высоким качеством!',
            9,
            '.menu .container',
            'menu__item',//напишем тот класс, который нам нужно туда поместить. пишем без точки, потому что мы его поместим в массив и используем в classList
            'big'
        ).render();
    
        new MenuCard(
            "img/tabs/elite.jpg",
            "elite",
            'Меню “Премиум”',
            'В меню “Премиум” мы используем не только красивый дизайн упаковки, но и качественное исполнение блюд. Красная рыба, морепродукты, фрукты - ресторанное меню без похода в ресторан!',
            14,
            '.menu .container'
        ).render();
    
        new MenuCard(
            "img/tabs/post.jpg",
            "post",
            'Меню "Постное"',
            'Меню “Постное” - это тщательный подбор ингредиентов: полное отсутствие продуктов животного происхождения, молоко из миндаля, овса, кокоса или гречки, правильное количество белков за счет тофу и импортных вегетарианских стейков.',
            21,
            '.menu .container'
        ).render(); */

    // Forms Формы у нас 2, поэтому функционал по отправке будет повторяться. Для этого мы обернем в функцию, которую будем вызывать при отправке формы

    const forms = document.querySelectorAll('form');//получим все формы, которые есть на странице
    const message = {//создадим объект для вывода сообщения. что у нас произошло при отправке данных
        loading: 'img/form/spinner.svg',//путь к картинке 

           

        success: 'Спасибо! Скоро мы с вами свяжемся',
        failure: 'Что-то пошло не так...'
    };


    //берем все наши формы и под каждую из них подвязать функцию bindPostData
    forms.forEach(item => {//все формы.метод forEach для перебора, далее говорим. что у нас там внутри какая то форма(item)
        bindPostData(item);//вызываем функцию bindPostData с этим item. Теперь на каждую форму подвязана функция bindPostData, котороая будет обработчиком события при отправке
    });

    //функционал для общения с сервером. функция отвечает за привязку постинга данных
    //аргументы которые приходят url и  data - данные, которые будут поститься в этой функции
    //Наша функция postData занимается тем, что настраивает нащ запрос, она посылает его на сервер, получает какой то ответ и трансформирует ответ в json
    const postData = async (url, data) => {//async внутри функции будет асинхронный код
        //помещаем в res промес, который будет возвращаться от fetch
        //передаем url и объект
        let res = await fetch(url, {//await ставится перед теми операциями, которые надо дождаться
            method: "POST",//метод отправки
            headers: {//указываем тип контента, что это JSON
                'Content-Type': 'application/json'
            },
            //что отправляем
            body: data//данные, которые будут поститься в этой функции
        });
        //далее res - которая будет промис, обработаем как json формат
        //из функции возвращаем res.json
        return await res.json();
    };

    async function getResource(url) {
        let res = await fetch(url);
    
        if (!res.ok) {
            throw new Error(`Could not fetch ${url}, status: ${res.status}`);
        }
    
        return await res.json();
    }

    //функция постинга данных
    //в качестве аргумента принимает форму, потому что это удобно, чтобы навесить обработчик события. Использовать будем submit. Оно срабатывает каждый раз. когда хотим отправить какую то форму.
    //Так же понадобится объект событие (е). Мы используем его, чтобы отменить стандартное поведение браузера. То есть нам надо, чтобы при отправке формы. страница не перезагружалась
    function bindPostData(form) {
        form.addEventListener('submit', (e) => {
            e.preventDefault();//Отменяет стандартное поведение браузера. эта команда должна идти в AJAX запросах в самом начале

            //когда будем отправлять запрос, очень частый прием, это создание блока на странице и туда выводить сообщение. Блок будет создаваться динамически и он добавляется чаще всего к форме
            //const statusMessage = document.createElement('div');//помещаем в див
            //statusMessage.classList.add('status');//так же можно добавить ему класс/ Если он есть в верстке, то будет применяться
            //statusMessage.textContent = message.loading;//Далее берем этот элемент и во внутрь помещаем при помощи textContent сообщение, которое хотим показать(message.loading = Загрузка)

            let statusMessage = document.createElement('img');//создаем img тэг
            statusMessage.src = message.loading;//обаращаясь к DOM узлу, сразу обращаемся к атрибуту src = далее обращаемся к message.loading, то есть мы создали изображение и подставили ему путь src, который получаем из объекта message
            //пропишем стили. cssText - прописать стили в формате инлайн к элементу
            //установим изобр по центру
            statusMessage.style.cssText = `
                display: block;
                margin: 0 auto;
            `;
            //form.append(statusMessage);//к форме добавлем это небольшое сообщение
            form.insertAdjacentElement('afterend', statusMessage);//insertAdjacentElement - более гибкий метод, который позволяет помещать элементы в разные места верстки. insertAdjacentElement(1 аргумент куда мы вставляем, в данном случае после формы - afterend, 2 аргумент, то что нужно вставить - statusMessage)

            //const request = new XMLHttpRequest();//продолжим работать с объектом XMLHttpRequest
            //request.open('POST', 'server.php');//вызываем метод open для настройки запроса. Указываем метод отправки и url

            //настройка заголовков, которые говорят серверу. что именно приходит
            //Когда используем связку XMLHttpRequest объекта + FormData нам заголовок устанавливать не нужно. Он устанавливается автоматически. Именно из за этой проблемы можно не получить данные на сервере
            //request.setRequestHeader('Content-type', 'multipart/form-data');

            //если данные требуется отправить в формате JSON
            //то заголовок в данном случае уже понадобится
            //request.setRequestHeader('Content-type', 'application/json');


            //Как сделать так, чтобы все данные которые заполнил польз-ль в форме, мы получили в JS и могли отправить на сервер
            //Самый простой способ подготовить данные для отправки из формы - это использовать объект formData.
            //formData - специальный объект, который позволяет с определенной формы быстро сформировать все данные, которые заполнил польз-ль. Формирует ключ: значение
            //ОЧЕНЬ ВАЖНО!! для работы formData обязательно указывать атрибут name в верстке у формы
        
            const formData = new FormData(form);//во внутрь помещаем ту форму из которой нам надо забрать данные

            //а вот далее надо объект formData, который нужно превратить в формат JSON

            //FormData довольно специфический объект и просто так прогнать в другой формат нет возможности
            //для этого мы создадим новый объект object
/*             const object = {};
            //Далее переберем formData с помощью forEach
            formData.forEach(function(value, key) {
                object[key] = value;//далее поместим все эти данные в object
            }); */

            //преображаем formData в JSON
            //создаем переменную json, используем JSON.stringify для преобразования объектов в JSON. 
            //entries - возвращает массив собственных перечисляемых св-в указанного объекта
            //fromEntries - из структуры массива делает объект. получив массив пар вида [ключ, значение] , он создаёт из них объект
            //мы берем нашу formData, которая собрала все данные из формы, првращаем ее в массив массивов formData.entries(), далее превращаем в классический объект Object.fromEntries, а после этот объект превращаем в JSON
            //данную строку читаем справа налево

            const json = JSON.stringify(Object.fromEntries(formData.entries()));

             //const json = JSON.stringify(object);
            //для конвертации в JSON создадим переменную в которую поместим с помощью stringify переведем обычный объект в формат JSON

            //request.send(json);//Далее берем json и помещаем для отправки

            //send для отправки. Так как используем метод POST, наобходимо указать body - данные отправляемые на сервер. В нашем случае это formData
            //request.send(formData);

            //логика
            //у нас уходит запрос с определенными данными, далее получаем ответ от сервера
            //если все ок. мы выводим в консоль console.log(request.response) результат
            //потом запускаем функцию showThanksModal с определ сообщением. что все успешно. у нас показывается модал окно и через 4 секунды оно будет закрываться вместе с текстом и возвращением того контента, который там будет/
            //далее идет form.reset(), чтобы данные все сбросились
            //statusMessage.remove() - удаляем спиннер, который есть на странице
            //если что то пошло не так, то мы вызываем ту же функцию showThanksModal, только с другим текстом

            //используем технологию fetch
/*             fetch('server.php', {//будем о бращаться к URL server.php. Куда отправляем
                //каким образом отправляем method и headers
                method: "POST",//постить
                headers: {//указываем тип контента, что это JSON
                    'Content-type': 'application/json'
                },
                //body что отправляем
                body: JSON.stringify(object)//преобразуем объект в JSON
                //body: formData//отправляем formData - специальный объект, который позволяет с определенной формы быстро сформировать все данные, которые заполнил польз-ль. Формирует ключ: значение
            }) */
            //используем функцию postData. помещаем url и данные в виде json отправляем на сервер
            postData('http://localhost:3000/requests', json)
            //.then(data => data.text())//модифицируем данные, которые приходят с сервера. В консоли увидим данные, которые были приняты сервером 
            .then(data => {//с сервера вернется какая то data
                console.log(data);//data те данные, которые вернул нам сервер
                showThanksModal(message.success);//показываем модал окно с сообщением об успешной отправке
                statusMessage.remove();//удаляем сообщение
            }).catch(() => {//для обработки ошибок используем catch
                showThanksModal(message.failure);//показать сообщение, если что то пошло не так
            }).finally(() => {//для выполнения действий, которые выполняются всегда не зависимо от результата(успешно или неуспешно)
                form.reset();//очищаем форму
            });
        });
    }

      //Особенность fetch: Promise ,который запускается с помощью fetch, не перейдет в состояние отклонено(rejected) из за ответа http, который считается ошибкой(404, 500, 501, 502 и тд). Он все равно выполнится нормально, у него поменяется только св-во статус, котрое перейдет в состояние false.
            
             
/*             request.addEventListener('load', () => {//Навешиваем обработчик события отслеживаем load - конечную загрузку нашего запроса
                if (request.status === 200) {//если request статус будет равен 200(запрос успешно завершен)
                    console.log(request.response);//response - ответ что успешно завершено

                    //statusMessage.textContent = message.success;//после успешной отправки данных, выведет сообщение. что success: 'Спасибо, Скоро мы с вами свяжемся'
                    showThanksModal(message.success);
                    form.reset();//очистить форму после отправки
                   // setTimeout(() => {//чтобы удалить наше сообщение о статусе отправки
                        statusMessage.remove();//используем setTimeout, где statusMessage удалить через 2 секунды
                   // }, 2000);
                } else {
                    showThanksModal(message.failure);
                    //statusMessage.textContent = message.failure;//иначе вывести failure: 'Что то пошло не так...'
                }
            }); */

    //функция красивого оповещения польз-ля
    function showThanksModal(message) {// передаем в кач-ве аргумента message - сообщение которое будет показываться польз-лю
        const prevModalDialog = document.querySelector('.modal__dialog');//в переменную prevModalDialog получаем по классу .modal__dialog наш элемент

        //скроем этот элемент перед показом модал окна
        prevModalDialog.classList.add('hide');//скроем с помощью добаавления класса hide
        //Далее наша задача открыть структуру modal show и сформировать внутри него
        openModal();//теперь когда вызывается showThanksModal у нас внутри подвязывается функция openModal - которая отвечает за открытие модальных окон 

        //Создание контента для оповещения
        //Для начала создадим блок обертку
        const thanksModal = document.createElement('div');//создадим div, который будет оборачивать красиво оповещение для польз-ля
        thanksModal.classList.add('modal__dialog');//назначим этому div классы, чтобы он как раз таки красиво выглядел. добавляем modal__dialog. Т.е. мы один  modal__dialog заменяем другим

        //формируем верстку, которая будет находиться в модал окне
        //обращаемся к thanksModal, обращаемся снова к innerHTML св-ву и во внутрь помещаем верстку
        //<div class="modal__content"> - див с оберткой с классом modal__content
        //<div class="modal__close" data-close>x</div> - крестик для закрытия модал окна с атрибутом data-close. Проблема в том что этот крестик, который будет создаваться динамически при верстке, он не будет реагировать на те действия, которые были повешены на него изначально. Там где мы создавали модал окно(122 строка), мы создали функцию closeModal, которая вешалась на modalCloseBtn. Эти селекторы мы получали по атрибуту data-close. Мы знаем, что если элементы создаются динамически, то обработчики событий уже не повесятся на него. Поэтому надо использовать делегирование событий. Поэтому смотрим выше, как поправил функционал, чтобы он работал со всеми кнопками. даже если они будут формироваться динамически. Продолжение 126, 161, 167 строки
        //<div class="modal__title">${message}</div> - в этот блок будем помещать сообщение о том, как завершился запрос
        thanksModal.innerHTML = `
           <div class="modal__content">
               <div class="modal__close" data-close>×</div>
               <div class="modal__title">${message}</div>
           
           </div>
        `;

        //помещаем на страницу thanksModal. Получаем модал окно modal и вставляем в него append элемент thanksModal
        document.querySelector('.modal').append(thanksModal);

        //потом польз-ль опять может открыть модал окно. чтобы что то отправить.
        //реализуем функционал, чтобы наш блок исчезал и все вернулось на свои места
        setTimeout(() => {//асинхронная операция с setTimeout. во внутрь помещаем callback функцию
            thanksModal.remove();//thanksModal - наш блок с оповещением поль-лю будем удалять через 4 секунды
            prevModalDialog.classList.add('show');//добавляем класс show для показа модал диалога с польз-лем
            prevModalDialog.classList.remove('hide');//удаляем класс hide 
            closeModal();//закрыть модал окно
        }, 4000);//через четыре секунды вызовется


   }

   //API - интерфейся программного обеспечения/приложения. Набор данных и возможностей, которые предоставляет какое то готовое решение
   //DOM API - различные методы, которые позволяют работать с элементами на старнице
   //Fetch API - встроена в браузер, позволяет общаться с сервером и она построена на промисах

   //Пример
   //Чтобы использовать fetch, раскрываем круглые скобки и помещаем URL, на который будем посылать запрос. Если не указывать доп параметров, то это обычный GET запрос
/*     fetch('https://jsonplaceholder.typicode.com/todos/1')//делаем запрос к todos и получаем только первую, которая будет на сервере
       .then(response => response.json())
       .then(json => console.log(json)); */

       //Для POST и PUT запроса надо поместить еще объект
/*     fetch('https://jsonplaceholder.typicode.com/posts', {
       method: "POST",//обязательное св-во. Устанавливаем метод отправки POST
       body: JSON.stringify({name: 'Alex'}),//обязательное св-во. Тело, которое будем отправлять
       headers: {//указываем заголовки для опредления контента
           'Content-type': 'application/json'
       }
   })//POST запрос
       .then(response => response.json())
       .then(json => console.log(json)); */
       
/* 	fetch('http://localhost:3000/menu')
   //fetch('db.json')
       .then(data => data.json())
       .then(res => console.log(res)); */

    // Slider
    //алгоритм работы
    //сначала надо получить все элементы. Далее нам понадобится параметр(индекс), который будет определять наш слайд(1-4). Этот индекс будем изменять, кликая по стрелкам. след этап написание функции, которая будет заниматься показом слайдов. Нам понадобится функция для показа и скрытия другого слайда. Повесим на стрелки события для клика слайдов.
    let offset = 0;//для определения отступа вправо или влево в слайдах
    //индекс для определения текущего положения в слайдере
    let slideIndex = 1;//поставили 1, потому что информацию будем выводить в человекоподобном варианте, когда первый слайд является 1. Поэтому использовали 1. В будущем это предусмотреть

    const slides = document.querySelectorAll('.offer__slide'),//кол-во слайдов на странице
        slider = document.querySelector('.offer__slider'),//получаем весь слайдер
        prev = document.querySelector('.offer__slider-prev'),//стрелочка prev, чтобы повесить обработчик события
        next = document.querySelector('.offer__slider-next'),//стрелочка next, чтобы повесить обработчик события
        total = document.querySelector('#total'),//для отображения количества слайдов (03/04)
        current = document.querySelector('#current'),//для отображения текущего слайда (03/04)
        slidesWrapper = document.querySelector('.offer__slider-wrapper'),//получаем главную обертку
        width = window.getComputedStyle(slidesWrapper).width,//для получения ширины блока
        slidesField = document.querySelector('.offer__slider-inner');//поле с нашими слайдами

    	//для проверки колва слайдов и текущего слайда если меньше 10, то подставляем 0 в нумерацию, если больше, то показываем без добвления 0 . Полное описание проверки ниже
    if (slides.length < 10) {
        total.textContent = `0${slides.length}`;
        current.textContent =  `0${slideIndex}`;
    } else {
        total.textContent = slides.length;
        current.textContent =  slideIndex;
    }
    
    slidesField.style.width = 100 * slides.length + '%';//устанавливаем ширину количество слайдов умножаем на 100%
    slidesField.style.display = 'flex';//чтобы выстроить все слайды в полоску назначаем стили в flex
    slidesField.style.transition = '0.5s all';//чтобы красиво и плавно передвигалось, используем transition

    slidesWrapper.style.overflow = 'hidden';//скрываем все элементы, которые не попадают в область видимости

    slides.forEach(slide => {//всеслайды, которые есть на странице , мы их все переберем(внутри есть каждый отдельный слайд)
        slide.style.width = width;//каждому отделтному слайду установим определенную ширину
    });

    slider.style.position = 'relative';//все абсолютно спозиционированные элементы в слайдере будут нормально отображаться

    //создание обертки для всех точек
    const indicators = document.createElement('ol'),//orderlist
          dots = [];//создаем массив, куда поместим точки
    indicators.classList.add('carousel-indicators');//добавляем класс
    //задаем стиль
    indicators.style.cssText = `
		position: absolute;
        right: 0;
        bottom: 0;
        left: 0;
        z-index: 15;
        display: flex;
        justify-content: center;
        margin-right: 15%;
        margin-left: 15%;
        list-style: none;
    `;
    slider.append(indicators);//помещаем обертку внутрь слайдера

    for (let i = 0; i < slides.length; i++) {
        const dot = document.createElement('li');//создаем точки
        dot.setAttribute('data-slide-to', i + 1);//каждой точке будем устанавливать атрибут data-slaide-to и будем ставить нумерацию , начиная с 1
        dot.style.cssText = `
            box-sizing: content-box;
            flex: 0 1 auto;
            width: 30px;
            height: 6px;
            margin-right: 3px;
            margin-left: 3px;
            cursor: pointer;
            background-color: #fff;
            background-clip: padding-box;
            border-top: 10px solid transparent;
            border-bottom: 10px solid transparent;
            opacity: .5;
            transition: opacity .6s ease;
        `;
        if (i == 0) {//для отображнния класса активности
            dot.style.opacity = 1;
        }
        indicators.append(dot);//аппендим точки в индикаторс
        dots.push(dot);//получим массив с точками
    }

function deleteNotDigits(str) {
    return +str.replace(/\D/g, '');
}

   //обработчик события передвигать слайды
   next.addEventListener('click', () => {//при клике запускаем колбэк функцию
    if (offset == deleteNotDigits(width) * (slides.length - 1)) {//если наш отступ будет равен ширине одного слайда умноженное на колво слайдов -1, то в таком случае
        offset = 0;//устанавливаем offset в 0. Это значит что долистали до самого конца и нужно вернуться в самое начало
        } else {//если это не последний слайд
            offset += deleteNotDigits(width) //то добавляем смещение
        }

    slidesField.style.transform = `translateX(-${offset}px)`;//насколько и куда будем смещать элемент по оси Х. Если сместить влево, то используем отрицательное значение вправо положительные, поэтому - используем перемеенную offset. То есть на сколько мы будем смещаться влево или вправо относительно 0. Важно указать меру px

    if (slideIndex == slides.length) {//если slideIndex будет равен количеству сладйов на странице
            slideIndex = 1;//это значит что я дошел до конца слайдера и надо переместится в первую позицию
        } else {//иначе
            slideIndex++;//slideIndex увеличиваем на 1
        }

        //в зависимости от slideIndex меняем значение
    if (slides.length < 10) {//если кол-во слайдов меньше 10
            current.textContent =  `0${slideIndex}`;//то к текущему сладйу подставляем 0
        } else {//иначе
            current.textContent =  slideIndex;//и slideIndex может быть болбше 10 и ноль подставлять не надо
        }

    dots.forEach(dot => dot.style.opacity = ".5");
    dots[slideIndex-1].style.opacity = 1;
    });

    //обработчик события prev 
prev.addEventListener('click', () => {
    if (offset == 0) {//проверяем первый слайд
            offset = deleteNotDigits(width) * (slides.length - 1);//то в переменную offset записываем последний слайд по формуле 
        } else {//а если был не первый слайд
           offset -= deleteNotDigits(width);//то отнимаем значение
        }

slidesField.style.transform = `translateX(-${offset}px)`;

    if (slideIndex == 1) {
        slideIndex = slides.length;
        } else {
            slideIndex--;//уменьшаем на единицу
        }

    if (slides.length < 10) {
        current.textContent =  `0${slideIndex}`;
        } else {
            current.textContent =  slideIndex;
        }

dots.forEach(dot => dot.style.opacity = ".5");
dots[slideIndex-1].style.opacity = 1;
    });

dots.forEach(dot => {
    dot.addEventListener('click', (e) => {
        const slideTo = e.target.getAttribute('data-slide-to');

        slideIndex = slideTo;
        offset = deleteNotDigits(width) * (slideTo - 1);

        slidesField.style.transform = `translateX(-${offset}px)`;

        if (slides.length < 10) {
            current.textContent =  `0${slideIndex}`;
        } else {
            current.textContent =  slideIndex;
        }

    dots.forEach(dot => dot.style.opacity = ".5");
    dots[slideIndex-1].style.opacity = 1;
        });
    });

/* 
//для инициализации слвйда. 
showSlides(slideIndex);//помещаем начальное значение, то есть приходит 1, она проходит проверки function showSlides(n), и далее мы показываем только первый слайд

if (slides.length < 10) {//если кол-во наших слайдов меньше 10
    total.textContent = `0${slides.length}`;//то возвращаем кол-во слайдов и спереди подставляем ноль(напрмер 02,03,04,)
} else {//если кол-во слайдов будет больше чем 10
    total.textContent = slides.length;//то вовнутрь помещаем кол-во слайдов без ноля(нопример 10,11,12)
}

//написание функций по показу и скрытию слайдов 
function showSlides(n) {//для показа слайдов. принимает параметр n - это будет приходить slideIndex с текущим положением
    if (n > slides.length) {//если n(slideIndex) будет больше, чем наша последняя граница(slides.length), то есть больше чем кол-во слайдов вообще в нашем слайдере
        slideIndex = 1;//то мы берем и перемещаемся в самое начало
    }
    if (n < 1) {//обратная ситуация, если n будет меньше, чем 1  
        slideIndex = slides.length;//то мы перемещаемся в конец(на последний слайд)
    }

    //теперь надо скрыть все сладйы на странице и показать только тот, который нас интересует
    slides.forEach((item) => item.style.display = 'none');//обращаемся ко всем слайдам slides, перебираем их forEach, дальше берем каждый слайд item и мы скрываем их item.style.display = 'none'

    //теперь берем нужный слайд, чтобы показать его
    slides[slideIndex - 1].style.display = 'block'; //обращаемся ко всем слайдам slides, так как это массив ставим [], говорим что нам понадобится slideIndex и пишем минус один -1. Так как нам надо показать первый слайд в человекоподобном варианте, то пишем -1, потому что отсчет начинаетс с 0 у машин. и указываем style.display = 'block', то есть отобразить
    
    //для отображения текущего слайда(01,02,03)
    if (slides.length < 10) {//если кол-во слайдов меньше 10
        current.textContent =  `0${slideIndex}`;//то к текущему слайду добавить ноль и отобразить его индекс
    } else {//иначе
        current.textContent =  slideIndex;//показывать текущий индекс
    }
}

//функция для изменения slideIndex
function plusSlides (n) {
    showSlides(slideIndex += n);//вызываем функцию showSlides, где slideIndex будет увеличен на n . в showSlides лежит необходимое число
}

//обработчки события для стрелок
prev.addEventListener('click', function(){
    plusSlides(-1);//когда нажимаем на prev, мы передаем -1, то есть перелистнуть на предыдущий слайд
});

next.addEventListener('click', function(){
    plusSlides(1);//когда нажимаем на next, мы передаем 1, то есть прибавляем, то есть перелистнуть на след слайд
});
*/

//calc

const result = document.querySelector('.calculating__result span');//получаем элемент, куда будем выводить результат калькулятора
let sex = 'female',//значение по умолчанию женский пол
height, weight, age,//для расчета понадобятся значения пола, веса, роста, возраста, активности
ratio = 1.375;//по умолчанию активность 

function calcTotal() {//функция подсчета результата
    if (!sex || !height || !weight || !age || !ratio) {//если нет пола или веса или роста или возраста или активности
        result.textContent='____';//то поместить в result для вывода на страницу '____'
        return;//для досрочного прерывания функции, если не указан какой то параметр
    }

    if (sex === 'female') {//если пол выбран женский, то произвести расчет по формуле. Math.round - округляем до целого
        result.textContent = Math.round((447.6 + (9.2 * weight) + (3.1 * height) - (4.3 * age)) * ratio);
    } else {//иначе пол выбран мужской, то произвести расчет по формуле. Math.round - округляем до целого
        result.textContent = Math.round((88.36 + (13.4 * weight) + (4.8 * height) - (5.7 * age)) * ratio);
    }
}

calcTotal();//запускаем функцию

//функция для получения статичных данных (пол и активность)
function getStaticInformation(parentSelector, activeClass) {//parentSelector - так как будем применять функцию на нескольких элементах, activeClass - так как будем менять класс активности
    const elements = document.querySelectorAll(`${parentSelector} div`);//получим элементы внутри этого блока. так как нужно получить divы внутри, используем бэктики, помещаем parentSelector, который передается в качестве аргумента функции, и говорю, что внутри этого родителя буду получать все  divы

    elements.forEach(elem => {//перебираем все элементы внутри
        elem.addEventListener('click', (e) => {//для каждого элема навешиваем событие
            if (e.target.getAttribute('data-ratio')) {//если объект события (e.target) получает атрибут data-ratio
                ratio = +e.target.getAttribute('data-ratio');//если такой атрибут присутствует у объекта события, то устанавливаем ratio ее значение и вытаскиваем у e.target
            } else {//для работы с полом
                sex = e.target.getAttribute('id');//получаем его по id
            }
    
            //для работы с классом активности
            elements.forEach(elem => {//обращаемся к элементам
                elem.classList.remove(activeClass);//убираем класс активности у всех элементов
            });
    
            e.target.classList.add(activeClass);//и назначаем его только тому, кому он нужен
    
            calcTotal();
        });
    })

}
//применение функции для получения статичных данных
getStaticInformation('#gender', 'calculating__choose-item_active');//#gender - id пола, calculating__choose-item_active - класс активности
getStaticInformation('.calculating__choose_big', 'calculating__choose-item_active');//.calculating__choose_big - получение родителя активности, calculating__choose-item_active - класс активности

////функция для получения динамически изменяемых данных (рост, вес, возраст)
function getDynamicInformation(selector) {//принимает только один аргумент, selector того инпута, котрый нас интересует
    const input = document.querySelector(selector);//получаем инпут, с которым будем работать

    input.addEventListener('input', () => {//навешиваем обработчик события на инпут
        switch(input.getAttribute('id')) {//проверяем с каким id вписывается инпут
            case 'height'://если это height
                height = +input.value;//то записываем данные в height
                break;//останавливаем case
            case 'weight':
                weight = +input.value;
                break;
            case 'age':
                age = +input.value;
                break;
        }
        calcTotal();
    });

    
}
//применение функции для получения динамических данных
getDynamicInformation('#height');
getDynamicInformation('#weight');
getDynamicInformation('#age');


    forms.forEach(item => {
        postData(item);
    });

    function postData(form) {
        form.addEventListener('submit', (e) => {
            e.preventDefault();

            let statusMessage = document.createElement('div');
            statusMessage.classList.add('status');
            statusMessage.textContent = message.loading;
            form.appendChild(statusMessage);
        
            const request = new XMLHttpRequest();
            request.open('POST', 'server.php');
            request.setRequestHeader('Content-type', 'application/json; charset=utf-8');
            const formData = new FormData(form);

            const object = {};
            formData.forEach(function(value, key){
                object[key] = value;
            });
            const json = JSON.stringify(object);

            request.send(json);

            request.addEventListener('load', () => {
                if (request.status === 200) {
                    console.log(request.response);
                    statusMessage.textContent = message.success;
                    form.reset();
                    setTimeout(() => {
                        statusMessage.remove();
                    }, 2000);
                } else {
                    statusMessage.textContent = message.failure;
                }
            });
        });
    }

});